# 📋 개발 계획서 - TensorFlow.js 기반 필기 인식 시스템

## 🎯 프로젝트 개요

초등학교 수학 학습 애플리케이션의 핵심 기능인 **TensorFlow.js 기반 필기 인식 시스템** 개발 계획서입니다.

### 핵심 목표
- **200x60px 캔버스**에서 연속된 숫자 '43525' 인식
- **85-90% 인식 정확도** 달성 (초등학생 필기 기준)
- **<500ms 응답 시간** 보장
- **완전 오프라인 동작** (인터넷 연결 불필요)

## 🚀 6단계 개발 계획

### Phase 1: 기본 캔버스 구현 (1-2일)

#### 목표
- 200x60px 드로잉 캔버스 구현
- 터치/마우스 입력 지원
- 기본 캔버스 조작 기능

#### 주요 작업
- [ ] **DrawingCanvas 컴포넌트** 구현
  - 200x60px 고정 크기 캔버스
  - 검은색 배경, 흰색 선 (교과서 답안란 시뮬레이션)
  - 2-3px 선 굵기 설정
- [ ] **터치/마우스 이벤트** 처리
  - `onMouseDown`, `onMouseMove`, `onMouseUp`
  - `onTouchStart`, `onTouchMove`, `onTouchEnd`
  - 포인터 좌표 정규화 (캔버스 내 상대 좌표)
- [ ] **캔버스 조작 기능**
  - 지우기 버튼 (`clearCanvas`)
  - 실행 취소 기능 (`undo`)
  - 캔버스 내용 이미지 추출 (`getCanvasImageData`)

#### 성공 기준
- 200x60px 캔버스에서 자연스러운 필기 가능
- 터치/마우스 입력 모두 정상 동작
- 캔버스 지우기 및 내용 추출 기능 정상 작동

### Phase 2: 이미지 전처리 시스템 (2-3일)

#### 목표
- 캔버스 이미지를 MNIST 모델 입력 형태로 변환
- 노이즈 제거 및 이미지 정규화
- 28x28 픽셀 이미지 생성

#### 주요 작업
- [ ] **이미지 추출 및 전처리**
  - `getImageData()` 활용한 픽셀 데이터 추출
  - 그레이스케일 변환 (`R * 0.299 + G * 0.587 + B * 0.114`)
  - 이진화 처리 (임계값 128 기준)
- [ ] **노이즈 제거**
  - 가우시안 블러 필터 적용
  - 모폴로지 연산 (침식/팽창)
  - 작은 연결 요소 제거
- [ ] **이미지 정규화**
  - 경계 박스 계산 및 크롭
  - 28x28 픽셀로 리사이즈
  - 중앙 정렬 및 패딩
  - 픽셀 값 정규화 (0-1 범위)

#### 성공 기준
- 손글씨 이미지가 28x28 픽셀로 정확히 변환
- 노이즈가 제거된 깨끗한 이미지 생성
- MNIST 모델 입력 형태와 일치

### Phase 3: 숫자 분할 알고리즘 (3-4일)

#### 목표
- 연속된 숫자 '43525'를 개별 숫자로 분할
- 겹치거나 붙어있는 숫자 처리
- 각 숫자를 28x28 이미지로 정규화

#### 주요 작업
- [ ] **수직 투영 기반 분할**
  - 각 열의 검은 픽셀 개수 계산
  - 투영 히스토그램 생성
  - 골짜기 지점에서 숫자 분할
- [ ] **연결 요소 분석**
  - 4방향 또는 8방향 연결성 검사
  - 각 연결 요소의 경계 박스 계산
  - 겹치는 숫자의 분할 지점 결정
- [ ] **분할 결과 후처리**
  - 너무 작은 영역 제거 (노이즈 제거)
  - 너무 큰 영역 재분할 (붙어있는 숫자)
  - 각 분할된 숫자를 28x28로 정규화

#### 성공 기준
- '43525' 입력 시 5개의 개별 숫자로 정확히 분할
- 각 분할된 숫자가 28x28 이미지로 변환
- 분할 정확도 90% 이상

### Phase 4: TensorFlow.js 모델 구현 (2-3일)

#### 목표
- MNIST 모델 로드 및 초기화
- 단일 숫자 예측 기능 구현
- 신뢰도 기반 결과 필터링

#### 주요 작업
- [ ] **TensorFlow.js 설정**
  - `@tensorflow/tfjs` 패키지 설치
  - 모델 로드 및 초기화
  - WebGL 백엔드 활용으로 성능 최적화
- [ ] **MNIST 모델 구현**
  - 사전 훈련된 MNIST 모델 로드
  - 또는 간단한 CNN 모델 구현
  - 모델 컴파일 및 최적화
- [ ] **예측 기능**
  - 28x28 이미지 텐서 변환
  - 모델 예측 실행
  - 신뢰도 점수 계산
- [ ] **메모리 관리**
  - 텐서 메모리 정리 (`dispose()`)
  - 배치 처리로 메모리 효율성 향상

#### 성능 목표
- 단일 숫자 예측 시간: <100ms
- 메모리 사용량: <50MB
- 예측 정확도: 95% 이상 (MNIST 기준)

### Phase 5: 통합 시스템 (2일)

#### 목표
- 전체 파이프라인 연결
- 연속 숫자 인식 구현
- 실시간 인식 결과 표시

#### 주요 작업
- [ ] **HandwritingRecognizer 클래스**
  - 전체 파이프라인 오케스트레이션
  - 각 단계별 에러 처리
  - 결과 캐싱 및 최적화
- [ ] **실시간 인식 시스템**
  - 캔버스 변경 감지
  - 디바운싱으로 불필요한 호출 방지
  - 진행 상태 표시 (로딩 인디케이터)
- [ ] **결과 표시 UI**
  - 인식된 숫자 표시
  - 각 숫자별 신뢰도 점수
  - 인식 소요 시간 표시
- [ ] **에러 처리**
  - 인식 실패 시 재시도 로직
  - 사용자 피드백 메시지
  - 폴백 메커니즘

#### 성공 기준
- '43525' 입력 시 정확한 인식 결과 출력
- 전체 파이프라인 응답 시간 <500ms
- 에러 없이 안정적인 동작

### Phase 6: 최적화 및 개선 (3-4일)

#### 목표
- 인식 정확도 향상
- 성능 최적화
- 초등학생 필기 특성 반영

#### 주요 작업
- [ ] **정확도 향상**
  - 전처리 파라미터 튜닝
  - 분할 알고리즘 개선
  - 모델 파인튜닝 (초등학생 필기 데이터)
- [ ] **성능 최적화**
  - 이미지 처리 알고리즘 최적화
  - 웹 워커 활용한 백그라운드 처리
  - 캐싱 전략 개선
- [ ] **사용자 경험 개선**
  - 실시간 피드백 시스템
  - 인식 과정 시각화
  - 사용자 입력 가이드
- [ ] **성능 모니터링**
  - 인식 정확도 추적
  - 응답 시간 모니터링
  - 메모리 사용량 분석

#### 최종 성능 목표
- **인식 정확도**: 85-90% (초등학생 필기 기준)
- **응답 시간**: <500ms
- **메모리 사용량**: <100MB
- **첫 로딩 시간**: <3초

## 🛠️ 기술 스택

### Core Technologies
- **TensorFlow.js**: 머신러닝 모델 실행
- **Canvas API**: 이미지 처리 및 드로잉
- **TypeScript**: 타입 안전성 보장
- **Next.js 14**: 프레임워크

### 주요 라이브러리
```bash
npm install @tensorflow/tfjs
npm install @tensorflow/tfjs-node  # 개발용
npm install canvas-to-blob
```

### 개발 도구
- **Jest**: 단위 테스트
- **Playwright**: E2E 테스트
- **ESLint**: 코드 품질 관리

## 📊 성능 지표 및 모니터링

### 핵심 지표
1. **인식 정확도**
   - 목표: 85-90%
   - 측정: 테스트 데이터셋 대비 정확도
   - 모니터링: 실시간 정확도 추적

2. **응답 시간**
   - 목표: <500ms
   - 측정: 캔버스 입력 → 결과 출력
   - 모니터링: 각 단계별 시간 측정

3. **메모리 사용량**
   - 목표: <100MB
   - 측정: 브라우저 메모리 사용량
   - 모니터링: 메모리 누수 감지

### 테스트 전략
- **단위 테스트**: 각 함수별 테스트
- **통합 테스트**: 전체 파이프라인 테스트
- **E2E 테스트**: 사용자 시나리오 테스트
- **성능 테스트**: 부하 테스트 및 벤치마크

## 🎯 위험 요소 및 대응 방안

### 주요 위험 요소
1. **인식 정확도 부족**
   - 대응: 전처리 알고리즘 개선, 모델 파인튜닝
   - 완화: 사용자 피드백 수집 및 반영

2. **성능 문제**
   - 대응: 웹 워커 활용, 알고리즘 최적화
   - 완화: 점진적 로딩, 캐싱 전략

3. **브라우저 호환성**
   - 대응: 폴리필 적용, 기능 감지
   - 완화: 대체 UI 제공

### 품질 보증
- **코드 리뷰**: 모든 PR 필수 리뷰
- **자동 테스트**: CI/CD 파이프라인 구축
- **사용자 테스트**: 베타 테스트 실시

## 📅 일정 및 마일스톤

### 전체 일정: 14-17일
- **Week 1**: Phase 1-2 (기본 캔버스, 이미지 전처리)
- **Week 2**: Phase 3-4 (숫자 분할, 모델 구현)
- **Week 3**: Phase 5-6 (통합, 최적화)

### 주요 마일스톤
- **Day 3**: 기본 캔버스 완성
- **Day 6**: 이미지 전처리 완성
- **Day 10**: 숫자 분할 완성
- **Day 13**: 모델 통합 완성
- **Day 15**: 시스템 통합 완성
- **Day 17**: 최적화 완성

## 🔄 다음 단계
이 개발 계획 완료 후:
1. **수학 문제 생성 시스템** 연동
2. **학습 진도 추적** 기능 개발
3. **AI 튜터 시스템** 통합
4. **성능 모니터링** 시스템 구축

---

**Updated**: 2025.01.09 - TensorFlow.js 기반 접근 방식으로 전환
